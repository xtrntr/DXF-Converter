#lang typed/racket

#| 

This module is where we define the structs, their constructors, custom types that build on combined structs and simple operations on entities/nodes.
Try to keep the more complex and specific functions in lst-utils.

|#

(require "utils.rkt")
(provide (all-defined-out))

(define-type Entity (U line arc path dot))
(define-type Entities (Listof Entity))

(struct node 
  ([x : Real]
   [y : Real])
  #:mutable #:transparent)

(struct entity
  ([highlighted : Boolean]
   [selected : Boolean]
   [visible : Boolean]
   [layer : String])
  #:mutable #:transparent)

(struct dot entity
  ([p : node])
  #:transparent)

(struct line entity 
  ([p1 : node]
   [p2 : node])
  #:transparent)

(struct arc entity 
  ([center : node]
   [radius : Real]
   [start : Real]
   [end : Real]
   [p1 : node]
   [p2 : node]
   [p3 : node]
   [ccw : Boolean]) 
  #:transparent #:mutable)

(struct path entity
  ([entities : (Listof (U line arc))])
  #:transparent)

;; CONSTRUCTORS
(: make-dot (-> String Real Real dot))
(define (make-dot layer x y)
  (dot #f #f #f layer (node x y)))

(: make-line (-> String Real Real Real Real line))
(define (make-line layer x1 y1 x2 y2)
  (line #f #f #f layer (node x1 y1) (node x2 y2)))

(: make-arc (-> String Real Real Real Real Real Boolean arc))
(define (make-arc layer center-x center-y radius start end ccw?)
  (match (get-arc-points center-x center-y radius start end ccw?)
    [(list x1 y1 x2 y2 x3 y3)
     (if ccw?
         (arc #f #f #f layer (node center-x center-y) radius start end (node x3 y3) (node x2 y2) (node x1 y1) #t)
         (arc #f #f #f layer (node center-x center-y) radius start end (node x1 y1) (node x2 y2) (node x3 y3) #f))]))

(: make-path (-> String (Listof (U line arc)) path))
(define (make-path layer lst)
  (path #f #f #f layer lst))

(: make-selected-path (-> String (Listof (U line arc)) path))
(define (make-selected-path layer lst)
  (path #f #t #t layer lst))

;; ENTITY OPERATIONS
(: reverse-direction (-> Entity Entity))
(define (reverse-direction a-struct)
  (let* ([layer : String (entity-layer a-struct)]
         [highlighted? : Boolean (entity-highlighted a-struct)]
         [selected? : Boolean (entity-selected a-struct)]
         [visible? : Boolean (entity-visible a-struct)]
         [reversed-struct : Entity ((match-struct (dot (make-dot layer (node-x p) (node-y p)))
                                                  (line (make-line layer (node-x p2) (node-y p2) (node-x p1) (node-y p1)))
                                                  (arc (make-arc layer (node-x center) (node-y center) radius start end (not ccw)))
                                                  (path (lambda (x) (make-path layer (reverse x)))))
                                    a-struct)])
    (when highlighted? (set-entity-highlighted! reversed-struct #t))
    (when selected? (set-entity-selected! reversed-struct #t))
    (when visible? (set-entity-visible! reversed-struct #t))
    reversed-struct))

(: are-entities-connected? (-> Entity Entity Boolean))
(define (are-entities-connected? x y)
  (or (node-equal? (get-entity-end x) (get-entity-end y))
      (node-equal? (get-entity-end x) (get-entity-start y))
      (node-equal? (get-entity-start x) (get-entity-end y))
      (node-equal? (get-entity-start x) (get-entity-start y))))

(: get-x-vals (-> Entities (Listof Real)))
(define (get-x-vals struct-lst)
  (let loop : (Listof Real)
    [(acc : (Listof Real) '())
     (lst : Entities struct-lst)]
    (cond ((empty? lst) acc)
          (else
           (match (car lst)
             [(struct* line  ([p1 p1]
                              [p2 p2]))              (loop (cons (node-x p1) (cons (node-x p2) acc)) (cdr lst))]
             [(struct* arc   ([center center]
                              [radius radius]))      (loop (cons (+ (node-x center) radius) (cons (- (node-x center) radius) acc)) (cdr lst))]
             [(struct* dot   ([p p]))                (loop (cons (node-x p) acc) (cdr lst))]
             [(struct* path  ([entities entities]))  (loop acc (append entities (cdr lst)))])))))

(: get-y-vals (-> Entities (Listof Real)))
(define (get-y-vals struct-lst)
  (let loop : (Listof Real)
    [(acc : (Listof Real) '())
     (lst : Entities struct-lst)]
    (cond ((empty? lst) acc)
          (else
           (match (car lst)
             [(struct* line  ([p1 p1]
                              [p2 p2]))              (loop (cons (node-y p1) (cons (node-y p2) acc)) (cdr lst))]
             [(struct* arc   ([center center]
                              [radius radius]))      (loop (cons (+ (node-y center) radius) (cons (- (node-y center) radius) acc)) (cdr lst))]
             [(struct* dot   ([p p]))                (loop (cons (node-y p) acc) (cdr lst))]
             [(struct* path  ([entities entities]))  (loop acc (append entities (cdr lst)))])))))

;separate a group of entities according to whether they are connected or not. 
;this does a node by node check so there may be "islands" that are actually connected"
(: separate-list-of-entities (-> Entities (Listof Entities)))
(define (separate-list-of-entities entity-lst)
  ;iterate through each value of entity-lst
  (let master : (Listof Entities)
    ([acc : (Listof Entities) '()]
     [remainder : Entities entity-lst])
    (cond ((empty? remainder) acc)
          (else (master (let sort :  (Listof Entities)
                          ([current : Entity (first remainder)]
                           [checked : (Listof Entities) '()]
                           [unchecked : (Listof Entities) acc])
                          (cond ((empty? unchecked) 
                                 (cons (list current)
                                       checked))
                                ((ormap (lambda ([check-against : Entity]) 
                                          (are-entities-connected? current check-against)) (first unchecked))
                                 (append (rest unchecked) 
                                         (list (cons current (first unchecked)))
                                         checked))
                                (else (sort current (cons (first unchecked) checked) (rest unchecked)))))
                        (rest remainder))))))

;compare 2 list of entities for any connection
(: lists-of-entities-connected? (-> Entities Entities Boolean))
(define (lists-of-entities-connected? lst1 lst2)
  (cond ((empty? lst1) #f)
        (else 
         (let loop : Boolean
           ([entity-lst : Entities lst2])
           (cond [(empty? entity-lst) (lists-of-entities-connected? (cdr lst1) lst2)]
                 [else (let ([x (car lst1)]
                             [y (car entity-lst)])
                         (cond [(are-entities-connected? x y) #t]
                               [else (loop (cdr entity-lst))]))])))))

;check a list of entities(listof entity) if they are connected, if yes then join them together.
(: sort-list-of-entities (-> (Listof Entities) (Listof Entities)))
(define (sort-list-of-entities entity-lst)
  (let master : (Listof Entities)
    ([acc : (Listof Entities) '()]
     [checked : (Listof Entities) '()]
     [unchecked : (Listof Entities) (rest entity-lst)]
     [current-list : Entities (first entity-lst)])
    (cond ((and (empty? checked) (empty? unchecked)) 
           (cons current-list acc))
          ((empty? unchecked) 
           (master (cons current-list acc) '() (rest checked) (first checked)))
          ((lists-of-entities-connected? current-list (first unchecked))
           ;if new current-list, recheck everything in checked - put checked into unchecked
           (master acc '() (append checked (rest unchecked)) (append current-list (first unchecked))))
          (else
           (master acc (cons (first unchecked) checked) (rest unchecked) current-list)))))

;i.e. from a path of 2 entities where the connection is (0,0)->(1,0)->(1,1) return (list (0,0) (1,1))
(: get-path-ends (-> (Listof node) (U (Listof node) Null)))
(define (get-path-ends lst)
  (let loop : (U (Listof node) Null)
    ([dupl : (Listof node) '()]
     [singles : (Listof node) '()]
     [lst : (Listof node) lst])
    (cond ((empty? lst) (remove* dupl singles node-equal?))
          ((ormap (lambda ([x : node]) (node-equal? (car lst) x)) singles)
           (loop (cons (car lst) dupl) (cons (car lst) singles) (cdr lst)))
          (else
           (loop dupl (cons (car lst) singles) (cdr lst))))))

;determine if a list of CONNECTED entities is a closed path or not. think of a horseshoe vs a circle.
(: closed-path-entity-list? (-> Entities Boolean))
(define (closed-path-entity-list? entity-lst)
  (define node-lst (entities->nodes entity-lst))
  (empty? (get-path-ends node-lst)))

;return all the start/end nodes given a list of entities. for an open path, this means the path ends, for a closed path, it can be any node along the path.
(: get-start/end-nodes (-> Entities (Listof node)))
(define (get-start/end-nodes entity-lst)
  (define node-lst (entities->nodes entity-lst))
  (if (closed-path-entity-list? entity-lst)
      node-lst
      (get-path-ends node-lst)))

;return all the nodes of the path given a list of entities
(: entities->nodes (-> Entities (Listof node)))
(define (entities->nodes entity-lst)
  (let ([start-nodes (map get-entity-start entity-lst)]
        [end-nodes (map get-entity-end entity-lst)])
    (append start-nodes end-nodes)))

 
;; NODE OPERATIONS
(: node-equal? (-> node node Boolean))
(define (node-equal? n1 n2)
  (and (> 0.5 (cast (abs (- (node-x n1) (node-x n2))) Float))
       (> 0.5 (cast (abs (- (node-y n1) (node-y n2))) Float))))

(: round-off-node (-> node node))
(define (round-off-node p)
  (node (round-3 (node-x p)) (round-3 (node-y p))))

(: get-entity-start (-> Entity node))
(define (get-entity-start a-struct)
  (round-off-node ((match-struct (dot p)
                                 (line p1)
                                 (arc p1)
                                 (path (lambda (x) (get-entity-start (first x)))))
                   a-struct)))

(: get-entity-end (-> Entity node))
(define (get-entity-end a-struct)
  (round-off-node ((match-struct (dot p)
                                 (line p2)
                                 (arc p3)
                                 (path (lambda (x) (get-entity-end (last x)))))
                   a-struct)))

(: make-mirror (-> Entities Void))
(define (make-mirror entity-lst)
  (let loop : Void
    ([x : Entities entity-lst])
    (cond ((empty? x) (void))
          (else
           (loop (rest x))
           (match (car x)
             [(dot highlighted selected visible layer p)                                     (set-node-y! p (* -1 (node-y p)))]
             [(line highlighted selected visible layer p1 p2)                                (set-node-y! p1 (* -1 (node-y p1)))
                                                                                             (set-node-y! p2 (* -1 (node-y p2)))]
             [(arc highlighted selected visible layer center radius start end p1 p2 p3 ccw)  (set-node-y! p1 (* -1 (node-y p1)))
                                                                                             (set-node-y! p2 (* -1 (node-y p2)))
                                                                                             (set-node-y! p3 (* -1 (node-y p3)))
                                                                                             (set-arc-start! (car x) (get-mirror-angle end))
                                                                                             (set-arc-end! (car x) (get-mirror-angle start))
                                                                                             (set-arc-ccw! (car x) (not ccw))
                                                                                             (set-node-y! center (* -1 (node-y center)))]
             [(path highlighted selected visible layer entities)                             (loop (path-entities (car x)))])))))

(define-syntax match-struct
  (lambda (stx)
    (syntax-case stx ()
      [(_ (dot a) (line b) (arc c) (path d))
       (with-syntax  ([tmp0 (syntax->datum #'a)]
                      [tmp1 (syntax->datum #'b)]
                      [tmp2 (syntax->datum #'c)])
         #'(lambda (a-struct)
             (match a-struct
               [(dot highlighted selected visible layer p)                                    tmp0]
               [(line highlighted selected visible layer p1 p2)                               tmp1]
               [(arc highlighted selected visible layer center radius start end p1 p2 p3 ccw) tmp2]
               [(path highlighted selected visible layer entities)                            (d entities)])))])))