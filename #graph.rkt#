#lang racket

(require graph
         "structs.rkt") ;stephen chang's graph library

(provide group-entities)

;; creates a hash map of
;;key -> node
;;value -> entities connected to that node
(define (make-node-hs entity-lst)
  (let ([hashy (hash)]
        [add-key-pair
         (lambda (entity hashy)
           (let ([ns (list (get-entity-start entity) (get-entity-end entity))]
                 [val (list entity)])
             (let loop
               ([keys ns]
                [ht hashy])
               (cond ([empty? keys] ht)
                     (else
                      (loop (rest keys)
                            (if (hash-has-key? ht (first keys))
                                (hash-set ht (first keys) (append (hash-ref ht (first keys)) val)) 
                                (hash-set ht (first keys) val))))))))])
    (let loop
      ([lst entity-lst]
       [ht hashy])
      (cond ([empty? lst] ht)
            (else
             (loop (rest lst)
                   (add-key-pair (first lst) ht)))))))

;; we can use node-equal here to check for similar keys
;; (get-duplicate-nodes (hash-keys node-ht)) then link the 2 groups together.
(define (sort-from-edges groups node-ht)
  (map
   (lambda (group)
     (remove-duplicates (flatten
                         (map
                          (lambda (element) (hash-ref node-ht element))
                          group))))
   groups))

(define (make-graph entity-lst)
  (unweighted-graph/undirected
   (map (lambda (entity) (list (get-entity-start entity) (get-entity-end entity)))
        entity-lst)))

(define (group-entities entity-lst)
  (let* ([edges (entities->edges entity-lst)] ;(Listof (List node node))
         [graph (unweighted-graph/undirected edges)]
         [groups (cc graph)]
         [node-hash (make-node-hs entity-lst)]
         [sorted (sort-from-edges groups node-hash)]
         [sub-graphs (map make-graph sorted)])
    ;Standard textbook depth-first search algorith, ie like in [CLRS]. Consumes a graph and returns three hashes:
    ;one that maps a vertex to its "discovery time",
    ;another that maps a vertex to its predecessor in the search,
    ;and a third that maps a vertex to its "finishing time".
    (for ([entity-lst sorted])
         (let*-values ([(graph) (make-graph entity-lst)]
                       [(discovery-time vertex-predecessor finishing-time) (dfs graph)])
           (display "entity-lst: ")
           (newline)
           (map display-entity entity-lst)
           (display "discovery-time: ")
           (display discovery-time)
           (newline)
           (display "vertex-predecessor: ")
           (display vertex-predecessor)
           (newline)
           (newline)))
    sorted))

;; (-> node Entities (Listof Entities))
(define (reorder-entities start-n entity-lst)
  (let* ([edges (entities->edges entity-lst)]
         [graph (unweighted-graph/undirected edges)]
         [new-edges (reorder-edges start-n edges)]
         [new-entities (map edges->entities new-edges)])
    new-entities))

(define (edge-connected? e1 e2)
  (or (equal? (first e1) (first e2))
      (equal? (first e1) (second e2))
      (equal? (second e1) (first e2))
      (equal? (second e1) (second e2))))

;e refers to edge
(define (e-find-edge e e-lst)
  (filter (lambda (e) (edge-connected? start-e e)) e-lst))

;n refers to node
(define (n-find-edge n e-lst)
  (filter (lambda (e) (or (equal? n (first e))
                          (equal? n (second e)))) e-lst))

(define (n-in-edge? edge n)
  (or (= (first edge) n)
      (= (second edge) n)))

(define (get-other-n edge n)
  (cond ([(equal? (first edge) n) (second edge)]
         [(equal? (first edge) n) (second edge)]
         [else (error "node not found in edge" n edge)])))

;; 1) find edge(s) from node
(define (reorder-edges start-n edges)
  (let*-values ([(discovery-time vertex-predecessor finishing-time) (dfs graph)])
    (let loop
        ([acc '()]
         [lst (rest edges)]
         [curr-n start-n]
         [curr-path '()])         
  (if (empty? lst) 
      acc
      (let ([ns (n-find-edge curr-n lst)])
        (cond [(empty? ns) (cons curr-path acc)]
              [(= 1 (length ns)) (loop acc (remove* ns lst) (get-other-n (first ns) start-n) (cons (first ns)) current-path)]
                                       
                  
            
